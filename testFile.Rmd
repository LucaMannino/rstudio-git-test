---
title: "Untitled"
author: "Luca Mannino"
date: "19/09/2022"
output:
  pdf_document: default
  html_document: default
---




my_log <- function(x) log(x - 1)

my_fun <- function(a, b) {
  # browser()
  la <- my_log(a) 
  lb <- my_log(b)
  la + lb
}
my_fun(1, 0)

#> Warning in log(x - 1): NaNs produced

#> [1] NaN

Try to uncomment browser() or use debugonce(my_fun):

debugonce(my_fun)
my_fun(1, 0)


```{r}
mat <- matrix(sample(c(TRUE, FALSE), 12, replace = TRUE), 3)
```

```{r}
matrix(as.integer(mat),3)
```

```{r}


mat + 0

```


```{r}
(vec <- 1:12)

#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12

dim(vec) <- c(3, 4)
vec
```



```{r}
head(iris)
```

```{r}
iris[,3,drop=FALSE]
```

```{r}
iris[,3]
```

```{r}
iris[3]

```

```{r}
advr38pkg::sum_every(1:10, 2)
```


```{r}
head(iris)
```

```{r}
colMeans(iris[-5])
```

```{r}
mat <- matrix(0, 10, 2); mat[c(5, 8, 9, 12, 15, 16, 17, 19)] <- 1; mat
```



```{r}
advr38pkg::sum_every(1:10, 2)
```

```{r}
function(sum_all) {
  temp_C <- (temp_F - 32) * 5 / 9
  return(temp_C)
}
```
```{r}
x <- 1:10
```
x

```{r}
n <- 2
```


```{r}
matrix(x, nrow = n)
```
```{r}
colSums(matrix(x, nrow = n))
```

```{r}
sum_all <- function(x, n) {
  sum <- colSums(matrix(x, nrow = n))
  return(sum)
}
```
```{r}
sum_all(x,n)
```


```{r}
colMeans(iris[-5])
```


```{r}
iris[sapply(iris, is.numeric)]
```
```{r}
colMeans(iris[sapply(iris, is.numeric)])
```


```{r}
mat <- matrix(0, 10, 2); mat[c(5, 8, 9, 12, 15, 16, 17, 19)] <- 1; mat
```


```{r}
decode <- matrix(c(0, NA, 1, 2), 2)
```

(0, 0) -> 0; (0, 1) -> 1; (1, 1) -> 2; (1, 0) -> NA
```{r}
#decode <- mat +1
```


```{r}
apply(mat,1, function(row) decode[row[1] +1, row[2] +1])
```

```{r}
apply(mat,1, function(row) decode[row+1])
```



```{r}
str(iris)
```

```{r}
skimr::skim(iris)
```


```{r}
x <- -5
abs(x)
```






```{r}
advr38pkg::split_ind(1:40, 3)
```

```{r}
sample(1:10)
```
```{r}
rep_len(1:3, 8)
```

Use sample(), rep_len() and split() to make a function that randomly splits some indices in a list of K groups of indices (like for cross-validation). [Which are the special cases that you should consider?]


```{r}
split(1:12, rep(letters[1:3], 4))
```

```{r}
x <- sample(1:10)
k <- 5
split(x,rep(letters[1:5],k))
```


```{r}
x <- 1:40
n <- 3

sample(seq_len(n), size = length(x), replace = TRUE)

rep_len(seq_len(n), length(x))
split(x, sample(n))
```
sample x with replacement 
compute the mean
do this 1000 times
get quantiles 2.5% and 97.5%

replicate()
```{r}
set.seed(1)
(x <- rnorm(10))
```



```{r}
set.seed(1)
x <- replicate(1000, mean(sample(rnorm(10))))
```



```{r}
set.seed(1)
x <- rnorm(10)

all_mean <- replicate(1000, {
          x2 <- sample(x, replace =TRUE)
          mean(x2)})
```

```{r}
hist(all_mean)
c1 <- quantile(all_mean, probs = c(0.025, 0.975))
c1
```

hist(all_mean)


```{r}
set.seed(1); (x <- rnorm(10))
all_mean <- replicate(1000, {
  (x2 <- sample(x, replace = TRUE))
  mean(x2)
})
hist(all_mean)
(ci <- quantile(all_mean, probs = c(0.025, 0.975)))
abline(v = ci, col = "chartreuse3")
abline(v = 0, col = "red")
```





```{r}
my_mtcars <- mtcars[c("mpg", "hp")]
my_mtcars$my_col <- sample(c("mpg", "hp"), size = nrow(my_mtcars), replace = TRUE)
head(my_mtcars)
```



```{r}
#my_mtcars$my_val <- my_mtcars$my_col

#my_mtcars$my_val[] == "hp" <-  my_mtcars$my_val[] = my_mtcars$hp[]
```


```{r}
col <- match(my_mtcars$my_col, colnames(my_mtcars))
row <- seq_len(nrow(my_mtcars))

sapply(seq_along(row), function(k) {
  my_mtcars[row[k], col[k]]
  
  
  
  
})


my_mtcars[1:2][cbind(row,col)]
```


```{r}
count1 <- 0
count2 <- 0
f <- function(i) {
  count1 <-  count1 + 1  ## will assign a new (temporary) count1
  count2 <<- count2 + 1  ## will assign count2 on top
  i + 1
}
sapply(1:10, f)
count1
count2
```


```{r}
f1 <- function(...) {
  list(...)
}
f1(a = 2, b = 3)
```
```{r}
summary(iris)
```




```{r}
agent007 <- list(first = "James", last = "Bond")
agent007

class(agent007) <- "Person"  ## "agent007" is now an object of class "Person"
# Just make a function called <method_name>.<class_name>()
print.Person <- function(x) {
  print(glue::glue("My name is {x$last}, {x$first} {x$last}."))
  invisible(x)
}


Person <- function(first, last) {
  structure(list(first = first, last = last), class = "Person")
}
(me <- Person("Florian", "PrivÃ©"))

Worker <- function(first, last, job) {
  obj <- Person(first, last)
  obj$job <- job
  class(obj) <- c("Worker", class(obj))
  obj
}
print.Worker <- function(x) {
  print.Person(x) 
  print(glue::glue("I am a {x$job}."))
  invisible(x)
}

(worker_007 <- Worker("James", "Bond", "secret agent"))
```





```{r}
methods(summary)
```


```{r}
list_of_int <- as.list(1:5)
do.call("c", list_of_int)
```




